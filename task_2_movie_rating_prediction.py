# -*- coding: utf-8 -*-
"""Task_2:Movie Rating Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14r796F_2em8L1poiCeUl9qxS-Cd8EVat

Task_2: Movie Rating Prediction

Importing Important Libraries
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
import numpy as np

"""Importing Dataset


"""

import pandas as pd
import io

# Open the file with error handling
with open('IMDb Movies India.csv', 'rb') as rawdata:
    data = rawdata.read().decode('utf-8', errors='replace')

# Create a DataFrame from the read data
data = pd.read_csv(io.StringIO(data))

# Load the dataset with error handling and decode it
with open('IMDb Movies India.csv', 'rb') as rawdata:
    data = rawdata.read().decode('utf-8', errors='replace')

# Create a DataFrame from the read data
df = pd.read_csv(io.StringIO(data))

# Check the shape of the DataFrame
print(df.shape)

# Describe the dataset
print(df.describe())

# View the top rows of the dataset (default is the first 5 rows)
print(df.head())

# Data preprocessing (replace column names and target variable)
X = df[['Votes', 'Rating']]
y = df['Rating']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

X_train['Votes'] = pd.to_numeric(X_train['Votes'], errors='coerce')

# Convert "Votes" column to numeric (handle non-numeric values as NaN)
X_train['Votes'] = pd.to_numeric(X_train['Votes'], errors='coerce')
X_train['Votes'].fillna(X_train['Votes'].mean(), inplace=True)

print(y_train.isna().sum())  # Check for NaN values
print(np.isinf(y_train).sum())

X_train = X_train[~y_train.isna()]
y_train = y_train.dropna()

# Create and train the XGBoost model (you can use other regression models as well)
model = XGBRegressor()
model.fit(X_train, y_train)

# Handle "Votes" column in X_test (convert to numeric and handle missing values)
X_test['Votes'] = pd.to_numeric(X_test['Votes'], errors='coerce')
X_test['Votes'].fillna(X_test['Votes'].mean(), inplace=True)

# Make predictions on the test set
y_pred = model.predict(X_test)

print(y_test.isna().sum())  # Check for NaN values in y_test

# Remove rows with NaN target values
not_nan_idx = ~y_test.isna()
y_test = y_test[not_nan_idx]
X_test = X_test[not_nan_idx]

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
print(f"Root Mean Squared Error: {rmse}")

with open('IMDb Movies India.csv', 'rb') as rawdata:
    new_data = rawdata.read().decode('utf-8', errors='replace')

# Create a DataFrame from the new data
new_df = pd.read_csv(io.StringIO(new_data))

# Data preprocessing for the new data (replace column names)
new_X = new_df[['Votes', 'Rating']]  # Assuming the column names are 'Votes' and 'Rating'
new_X['Votes'] = pd.to_numeric(new_X['Votes'], errors='coerce')
new_X['Votes'].fillna(new_X['Votes'].mean(), inplace=True)

# Make predictions on the new data using the trained model
new_predictions = model.predict(new_X)

# Add the predictions to the new DataFrame
new_df['Predicted_Rating'] = new_predictions

# Save the new DataFrame with predictions to a CSV file
new_df.to_csv('new_movies_with_predictions.csv', index=False)